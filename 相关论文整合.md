下面是我找到的与程序比对及中间语言相关的论文，在这里记录一下，再找到相关论文，后续补充～
---

## Semantics-Based Obfuscation-Resilient Binary Code Similarity Comparison with Applications to Software and Algorithm Plagiarism Detection
（IEEE Transactions on Software Engineering 2017）

- [paper](https://ieeexplore.ieee.org/stamp/stamp.jsp?tp=&arnumber=7823022&tag=1) </br>

__Abstract__: Existing code similarity comparison methods, whether source or binary code based, are mostly not resilient to obfuscations. Identifying similar or identical code fragments among programs is very important in some applications. For example, one application is to detect illegal code reuse. In the code theft cases, emerging obfuscation techniques have made automated detection increasingly difficult. Another application is to identify cryptographic algorithms which are widely employed by modern malware to circumvent detection, hide network communications, and protect payloads among other purposes. Due to diverse coding styles and high programming flexibility, different implementation of the same algorithm may appear very distinct, causing automatic detection to be very hard, let alone code obfuscations are sometimes applied. In this paper, we propose a binary-oriented, obfuscation-resilient binary code similarity comparison method based on a new concept, longest common subsequence of semantically equivalent basic blocks , which combines rigorous program semantics with longest common subsequence based fuzzy matching. We model the semantics of a basic block by a set of symbolic formulas representing the input-output relations of the block. This way, the semantic equivalence (and similarity) of two blocks can be checked by a theorem prover. We then model the semantic similarity of two paths using the longest common subsequence with basic blocks as elements. This novel combination has resulted in strong resiliency to code obfuscation. We have developed a prototype. The experimental results show that our method can be applied to software plagiarism and algorithm detection, and is effective and practical to analyze real-world software.

## Wire -- A Formal Intermediate Language for Binary Analysis (中间语言)
(2012 IEEE 11th International Conference on Trust, Security and Privacy in Computing and Communications)

- [paper](https://ieeexplore.ieee.org/stamp/stamp.jsp?tp=&arnumber=6296015)

__Abstract__:Wire is a intermediate language to enable static program analysis on low level objects such as native executables. It has practical benefit in analysing the structure and semantics of malware, or for identifying software defects in closed source software. In this paper we describe how an executable program is disassembled and translated to the Wire intermediate language. We define the formal syntax and operational semantics of Wire and discuss our justifications for its language features. We use Wire in our previous work Malwise, a malware variant detection system. We also examine applications for when a formally defined intermediate language is given. Our results include showing the semantic equivalence between obfuscated and non obfuscated code samples. These examples stem from the obfuscations commonly used by malware.

## Efficient features for function matching between binary executables
( 2018 IEEE 25th International Conference on Software Analysis, Evolution and Reengineering (SANER))

- [paper](https://ieeexplore.ieee.org/stamp/stamp.jsp?tp=&arnumber=8330221)

__Abstract__:Binary diffing is the process of reverse engineering two programs, when source code is not available, in order to study their syntactic and semantic differences. For large programs, binary diffing can be performed by function matching which, in turn, is reduced to a graph isomorphism problem between the compared programs' CFGs (Control Flow Graphs) and/or CGs (Call Graphs). In this paper we provide a set of carefully chosen features, extracted from a binary's CG and CFG, which can be used by BinDiff algorithm variants to, first, build a set of initial exact matches with minimal false positives (by scanning for unique perfect matches) and, second, propagate approximate matching information using, for example, a nearest-neighbor scheme. Furthermore, we investigate the benefits of applying Markov lumping techniques to function CFGs (to our knowledge, this technique has not been previously studied). The proposed function features are evaluated in a series of experiments on various versions of the Linux kernel (Intel64), the OpenSSH server (Intel64) and Firefox's xul.dll (IA-32). Our prototype system is also compared to Diaphora, the current state-of-the-art binary diffing software.

## Towards reverse engineering of intermediate code for documentation generators
(2017 IEEE 24th International Conference on Software Analysis, Evolution and Reengineering (SANER))

- [paper](https://ieeexplore.ieee.org/stamp/stamp.jsp?tp=&arnumber=7884673)

__Abstract__:We describe the motivation, approach and first experience from reverse engineering Common Intermediate Language (CIL) for the purpose of documentation generation. Instead of parsing source code implemented in different programming languages, we reverse engineer CIL code and thereby enable documentation generation for all programming languages that can be compiled into CIL code. Initial results show that we are able to generate documents in the same quality as compared to directly analyzing source code. To overcome initial shortcomings we introduce additional preprocessing in form of AST refactoring which is not required when analyzing source code.




